# 虚拟路由实验报告

---

## 实验介绍

>  本实验在小组成员的主机之间，根据选定的虚拟网络拓扑图建立虚拟连接；并且在建立的虚拟网络中选用不同的路由算法（LS 或 DV），生成网络中的路由信息，实现主机之间的数据传输。实验主要分为两部分，一部分是自组织的路由，另一部分是中心化的路由。

---

## 实验分工

| 角色 | 姓名   | 学号     | 贡献                                                         |
| :--- | :----- | -------- | ------------------------------------------------------------ |
| 组长 | 刘硕   | 16340154 | 负责实验自组织路由部分的代码的实现和测试、相关实验报告的编写及最终的整合。 |
| 组员 | 刘虹奇 | 16340148 | 负责采用 DV 算法的中控路由部分的代码实现，以及实验报告设计部分的完成。 |
| 组员 | 聂博业 | 16340157 | 负责采用 DV 算法的中控路由部分的代码测试和修改，以及实验报告实验部分的完成。 |
| 组员 | 许博阳 | 15331337 | 负责采用 LS 算法的中控路由部分的代码实现和测试，以及实验报告相关部分的完成。 |
|      |        |          |                                                              |

---

## 实验设计



### 数据结构定义

- **主机地址**：IP | 子网掩码 | 端口
- **数据包**：源地址 | 目的地址 | 内容 | 包类型
- **OSPF协议的路由表表项**：目的地址 | 下一跳地址
- **RIP协议的路由表表项**：目的地址 | 下一跳地址 | 到目的地的跳数



### 自组织路由

#### 数据传输

**实验中，采用 UDP 进行数据传输**。在每一台主机上，选用两个端口，$Port_{in}$ 和 $Port_{out}$ ，分别用于接收数据和发送数据。使用套接字，在主机之间进行数据传输。每台主机从输入端口接受收的数据，并进行相应的处理。

#### 路由算法

>  实验中选用 **OSPF 和 RIP** 两种选路协议，分别对应于 **LS 和 DV** 的路由算法。

##### OSPF 协议

每一台主机都会维护一个自己的网络拓扑图，并定期地向网络内的所有其他主机广播自己的链路状态信息。每台主机都根据从 $Port_{in}$ 端口收到的链路状态信息，更新自己维护的网络拓扑图，通过 Dijkstra 最短路径算法生成自己的路由表。

##### RIP 协议

每一台主机都会定期地向网络内的相邻主机广播自己的距离向量信息（个体转发表）。每台主机都根据从 $Portin$ 端口收到的选路信息，更新个体转发表。主机更新本地路由的同时，都会向相邻的节点发送新的距离向量。转发表中使用跳数作为费用测度，即每一条链路的计为1跳，费用为1。此外，每一条路径的最大费用被限制为15，若大于15，则被视为该目的主机不可达。

#### 发送数据

当主机要发送一个普通的数据包 M 或是从别的主机收到一个数据包 M 需要转发时，主机查询自己的路由表：若路由表中存在该表项，将其发送到该目的地址对应的下一跳主机；若路由表中无对应表项，则将其丢弃。

#### 宕机检测

##### OSPF 协议

实验中，主机之间都定时地向其他所有主机发送链路状态信息。每台主机（e.g. A）都记录着与这台主机（e.g. B）上一次交换路由信息的时间。若在指定时间内，A 还未接收到 B 下一次的路由信息，则 A 就会判定 B 已经发生故障。这时，A 就会将 B 从自己维护的网络拓扑图中移除，然后通过 Dijkstra 最短路径算法重新生成自己的路由表。

##### RIP 协议

实验中，主机之间都定时地向相邻主机发送距离向量信息。每台主机（e.g. A）都记录着与这台主机（e.g. B）上一次交换路由信息的时间，若超过指定时间，A还未接收到B下一次的路由信息，则A就会判定B已经发生故障。这时，为避免路由环路，A 会采用 "**毒性反转**"（*当一条路径信息变为无效之后，路由器并不立即将它从路由表中删除，而是用16，即不可达的度量值将它广播给相邻的主机*）的方式将 B 故障的消息广播出去，让所有主机都得到 B 故障的消息并更新自己的路由信息。



### 中心化路由

#### 数据传输

数据传输部分与自组织路由相同，采用 UDP 进行数据传输。在每一台主机上，选用两个端口，$Port_{in}$ 和 $Port_{out}$ ，分别用于接收数据和发送数据。每台主机通过 $Port_{out}$ 向控制主机 Server 发送信息。控制主机收集处理各节点发来的信息得到路由表，将路由表发送至每台主机的 $Port_{in}$ 端口。

#### 路由算法

> 中心化路由同样选用 **LS 和 DV** 两种路由算法，对应于 **OSPF 和 RIP** 两种选路协议。

##### OSPF 协议

每台主机定期向控制主机 Server 发送自己的链路状态信息。控制主机 Server 收到每台主机发送来的信息后可以构建出整个网络的拓扑结构并不断更新，通过 Dijkstra 最短路径算法为每个发送来信息的主机计算出其路由表，并将路由表返回给相应的主机。

##### RIP 协议

每台主机定期向控制主机 Server 发送自己的路由表信息。接收到每台主机发送过来的路由表信息之后，根据 DV 算法更新发送信息主机相邻主机的路由表信息，将更新后的路由表信息发送给路由表改变的主机。

#### 宕机检测

##### OSPF 协议

实验中，主机之间都定时地向其他所有主机发送链路状态信息。每台主机（e.g. A）都记录着与这台主机（e.g. B）上一次交换路由信息的时间。若在指定时间内，A 还未接收到 B 下一次的路由信息，则 A 就会判定 B 已经发生故障。这时，A 就会将 B 从自己维护的网络拓扑图中移除，然后通过 Dijkstra 最短路径算法重新生成自己的路由表。

##### RIP 协议

实验中，主机之间都定时地向相邻主机发送距离向量信息。每台主机（e.g. A）都记录着与这台主机（e.g. B）上一次交换路由信息的时间，若超过指定时间，A还未接收到B下一次的路由信息，则A就会判定B已经发生故障。这时，为避免路由环路，A 会采用 "**毒性反转**"（*当一条路径信息变为无效之后，路由器并不立即将它从路由表中删除，而是用16，即不可达的度量值将它广播给相邻的主机*）的方式将 B 故障的消息广播出去，让所有主机都得到 B 故障的消息并更新自己的路由信息。

---

## 实验部署

### 自组织路由

> 自组织路由的实现文件如下。

Configuration/Nodes 中的是每台主机的配置信息，包括主机名，IP，子网掩码，端口号。主机通过读取该文件，获取其他主机的配置信息。其中，5台主机的接收端口Portin分别配置为30001,30002,30003,30004,30005.